namespace DiagnosableExceptions;

/// <summary>
///     Represents the stage in the error documentation building process where diagnostics or examples of the error can be
///     specified.
/// </summary>
public interface IErrorExamplesOrDiagnosticsStage {

    /// <summary>
    ///     Adds another documented diagnostic scenario describing a plausible cause of the error and a corresponding direction
    ///     for
    ///     investigation.
    /// </summary>
    /// <param name="cause">
    ///     A concise description of a plausible state of the domain or system that could explain the error. This should
    ///     represent a meaningful situation (e.g., invalid input, inconsistent data, unexpected system behavior), not a
    ///     technical symptom or exception detail.
    /// </param>
    /// <param name="type">
    ///     A classification indicating whether the problem most likely originates from input data, internal system logic, or
    ///     both. This helps orient investigation and does not imply blame.
    /// </param>
    /// <param name="analysisLead">
    ///     A direction to explore when investigating this diagnostic scenario. This must guide <b>where to look</b>, not
    ///     <b>what to fix</b>. Prefer verbs such as "Verify", "Check", "Examine", or "Inspect". Avoid corrective instructions
    ///     (e.g., "Fix", "Correct", "Ensure") and references to specific tools or support processes.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         Diagnostics capture <b>diagnostic knowledge</b> about the error, helping readers reason about why it may have
    ///         occurred and where investigation should begin.
    ///     </para>
    ///     <para>
    ///         Each diagnostic represents one possible explanation. Multiple calls to this method can be used to document
    ///         alternative causes.
    ///     </para>
    /// </remarks>
    IErrorExamplesOrDiagnosticsStage AndDiagnostic(string cause, ErrorCauseType type, string analysisLead);

    /// <summary>
    ///     Adds one or more example exception instances illustrating how this error may appear at runtime.
    /// </summary>
    /// <typeparam name="TException">
    ///     The type of <see cref="DiagnosableException" /> produced by the example factories.
    /// </typeparam>
    /// <param name="exampleFactories">
    ///     Factories that create representative exception instances using realistic example values.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         Examples are used to expose <b>realistic error messages</b> generated by the exception, helping readers
    ///         recognize the error in logs, monitoring tools, or user interfaces.
    ///     </para>
    ///     <para>
    ///         Instead of hard-coded message strings, factories are used so that the examples always reflect the actual
    ///         message format produced by the exception implementation. This prevents message drift and duplication.
    ///     </para>
    ///     <para>
    ///         Each factory should construct an exception using plausible domain values (e.g., dates, identifiers, amounts,
    ///         units) that illustrate a typical failure case. These examples are descriptive, not executable scenarios or
    ///         tests.
    ///     </para>
    ///     <para>
    ///         <b>Writing guidance:</b>
    ///     </para>
    ///     <list type="bullet">
    ///         <item>Use realistic but simple values that clearly demonstrate the violation.</item>
    ///         <item>Avoid edge cases meant for testing rather than illustration.</item>
    ///         <item>Ensure the example focuses on the rule violation, not on technical side effects.</item>
    ///     </list>
    /// </remarks>
    ErrorDocumentation WithExamples<TException>(params Func<TException>[] exampleFactories)
        where TException : DiagnosableException;

}